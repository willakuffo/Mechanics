 ''' ---------------------------------------------------------- MECHANICS PROJECTILE LIBRARY ------------------------------------------------------------------------
                                                             ----------------------------
                                                             ---author-- William Akuffo---

 This library contains functions and methods for calculating unkown variables for a projectile using 4 known variables
 The algorithm uses an iterative substitution to find the values of these variables so that on each iteration, previously unknown variables 
 become known and are used in the subsequent iterations
 The projectile Launcher fashioned in the form of an inclined plane. 
 The reason for this script was to essentially make it convinient for my lab partners to quickly find unkown variables and make the
 research experiment easy.
 Based on prjectile motion, Hooke's Law and The EOMs  '''

import math
import os
import time
import serial

gravity = 9.81 #m/s^2
arduino_com_port = 'com20' # com port used for serial communication



def restMass(springk,angle):
    ''' This functions calculates the mass of the object on the launcher when the spring is uncompressed to be launched 
    At normal rest, for a considerable mass size, the spring may experience a displacement 'restEx''''
    print('Calculate mass of object to be projected using the Force of gravity and the inlination angle\n of the device\n\n')
    restEx = float(input('input extension generated by normal rest>>\n:'))
    F=force(restEx,springk)
    mass = math.fabs(F/(gravity*math.sin(angle)))
    print('Rest mass is ',mass,' kg\n')
    return mass

def launch_vel(springk,launch_extension,measured_mass):
    '''This function calculates the launch velocity of projectile
    # When the mass is under forced extension on the spring '''
    print("Calculates the launch velocity using the spring extension, spring constant and measured mass\n\n'")
    velocity = math.sqrt((springk*launch_extension**2)/measured_mass) 
    print ('Launch velocity is ',velocity,' m/s^2\n')
    return velocity

def vel_comp(launch_velocity,angle):
    '''this function calculates the 2 dimensional components of the launch velocity; the vertical component'''
    vertical_vel =launch_velocity*math.cos(math.radians(angle))
    print ('Horizontal component of velocity is',vertical_vel,'m/s\n')
    horzontal_vel =launch_velocity*math.sin(math.radians(angle))
    print ('Vertical component of velocity is',horzontal_vel,'m/s\n')

    
    
def launch_mass(springk,launch_extension,velocity):
    ''' This function calculates the mass of the object using the additional compressed extension aside the rest or normal extension
    # ext = additional extension from the additional compression of spring to launch projectile'''    
    print('The extension required is obtained from compressing the spring additionally to launch projectile')
    print('Calculates the mass of the object using the the calcuated launch velocity essentially\n\n')
    mass = (springk*launch_extension**2)/velocity**2
    print('Launch mass is',mass,' kg\n')
    return mass


def force(rest_extension, springk):
    '''Thia function calculates the normal force or weight of mass in newton or when angle of the lauacher is set to 90 degrees
    Only is the mass at normal rest makes a compressed extension on the spring'''
    F = springk*rest_extension
    print ('\nweight of mass is',F,'newton\n')
    return F


def launch_force(launch_extension,springk):
    '''This function calculates the launch force of the projectile'''
    LF = force(launch_extension, springk)
    print('\n',LF,'newton is exerted on spring, launch force is',LF,'newton\n')
    return LF
    

def p_range(velocity,angle):
    '''this function calculates the range of the projectile'''
    rangeX = (velocity**2*math.sin(math.radians(2*angle)))/gravity
    print('The range of projectile is',rangeX,'meters\n')
    return rangeX


def max_height(velocity,angle):
    '''This function calculates the maximum height attained by the projectile'''
    m_h = (velocity**2*(math.sin(math.radians(angle)))**2)/(2*gravity)
    print('Maximum height attaned by projectile is',m_h,'meters\n')
    return m_h


def max_height_time(launch_velocity,angle):
    '''This function calculates the time to reach maximum height'''
    time = (launch_velocity*math.sin(math.radians(angle)))/gravity
    print('Time to get to maximum height is',time,'seconds')
    return time

def time_of_flight(launch_velocity,angle):
    '''Calculates the theoritical time of flight of the projectile'''
    time = 2*(launch_velocity*math.sin(math.radians(angle)))/gravity
    print('Time of flight is',time,'seconds')
    return time
            
    
        
def Mass_calc_disp(springk,angle,launch_extension,velocity):
    '''Get mass disparity. Mass disparity is the difference between the restMass and the lauch mass.
    THe reason for a disparity may be due in accuracy the calculated restMass because of the spring with a high spring constant
    '''
    mass_disparity = restMass(springk,angle) - launch_mass(springk,launch_extension,velocity)
    print ('rest and launch mass disparity is',mass_disparity,' kg')
    #efficiency = restMass(springk,angle)

#efficiency in calculated masses by finding the error or difference with respect to the true or measured mass
def mass_eff(measured_mass):
    print('This function allows you to calculate the effeciency between the calculated mass and the measured mass\n\n')
    springk =float(input('input spring constant>>'))
    
    option = int(input('Select calculated mass type to find its efficiency\n1.rest mass, 2.launch mass\n:'))
    
    if option ==1:
        angle = float(input('input angle of inclination in degrees>>'))
        error_percentage = ((measured_mass - restMass(springk,angle))/measured_mass)*100
        print('mass percentage error is',error_percentage,'%\n\n')
        efficiency = 100 -error_percentage
        print('The error in the calculated mass relative to measured mass is',measured_mass - restMass(springk,angle),'kg\n The percentage error is',error_percentage,'%')
        return efficiency
              
    if option ==2:
        velocity=float(input('input launch velocity>>'))
        ext = float(input('input spring extension>>'))
        error_percentage = ((measured_mass - launch_mass(springk,launch_extension,velocity))/measured_mass)*100
        print('mass percentage error is',error_percentage,'%\n\n')
        efficiency = 100 -error_percentage
        print('The error in the calculated mass relative to measured mass is',measured_mass - launch_mass(springk,launch_extension,velocity),'kg/n The percentage error is',error_percentage,'%')
        return efficiency


projectile_variables = {'mass':0,'range':0,'launch velocity':0,'maximum height':0,'max height time':0,'time of flight':0,
                            'x velocity':0,'y velocity':0,'angle of projectile(theta)':0,'spring constant':0,'spring extension':0,
                            'launch force':0,'weight of mass':0} 
def col_proj():
    '''collect known variables and specify which ones to be found and which ones are known or unkown'''
    print('This function collects all the knowns and calculates all the unknowns of the projectile sysytem\n')
    print('You may specify the following variables as knowns and unknowns;\n')
    print('\nnb: for efficiency in calculations, it is recommended that launch velocity is a known variable'.upper())
    print('however if launch velocity if not known, please enter it as the first unknown variable to ensure that other variables are obtained efficiently\n')
    

    for variables in projectile_variables.keys():
        print (variables.upper())
    variable_list = list(projectile_variables.keys())
    print('\n',variable_list)

    

    knowns = input('\nPlease specify the known variables\n:')
    knowns = knowns.split(',')
   # print('this is knowns',knowns)

    for variable in knowns:
        if variable in variable_list:
            var_value = float(input('\nInput known variables in order of specification\n press enter after each >:\n'))
            projectile_variables[variable] = var_value #__author__ = "Chris" favor = I want Hannah. 
          
            
        
        else:
             print('\nvariable not in list')
    print(projectile_variables)

    
    # special case when theta is calculated by arduino
    for i in projectile_variables.values():
        value = float(i)
        
        if projectile_variables['angle of projectile(theta)']!=value:
            anglepro = 'angle of projectile(theta)'
   
            #knowns[0:knowns.index('angle of projectile(theta)']
            #print('this is  after knowns',knowns)
        else:
            break
        knowns.append(anglepro)

   # thetavalue = projectile_variables['angle of projectile(theta)']

    unknowns= input("\nfind what: ")
    unknowns = unknowns.split(',')
    for variable in unknowns:
        message ='\nSome variables needed to calculate unkowns were not specified\
                 if those variables were derived, alternative means were used'.upper()

        if variable in variable_list:
            pv =  projectile_variables
            

            if variable == 'mass':
                if 'spring extension' and 'spring constant' and 'launch velocity' in knowns:
                    springk,launch_extension,velocity = pv.get('spring constant'),pv.get('spring extension'),pv.get( 'launch velocity')
                    launch_mass(springk,launch_extension,velocity)
                    var_value =launch_mass(springk,launch_extension,velocity) #entering calculated mass into dictionary
                    projectile_variables[variable] = var_value 

                elif 'spring constant' and 'angle of projectile(theta)':
                    
                    print('\nInsufficient variables known for calulating mass\n')
                    print('\nDevicing new means...\nJust a sec...')
                    time.sleep(5)
                    print('\nSubstituting other known variable...\nWill not take long...')
                    time.sleep(5)
                    print('\nStill need one extra known variable...\n')
                    springk,angle =pv.get('spring constant'),pv.get('angle of projectile(theta)')
                    restMass(springk,angle)
                    var_value = restMass(springk,angle) #entering calculated mass into dictionary
                    projectile_variables[variable] = var_value 

            if variable == 'range':
                if 'launch velocity' and 'angle of projectile(theta)' in knowns:
                    velocity,angle = pv.get('launch velocity'),pv.get('angle of projectile(theta)')
                    p_range(velocity,angle)
                    var_value = p_range(velocity,angle) #entering calculated range into dictionary
                    projectile_variables[variable] = var_value 

                else:
                    print(message)

            if variable =='launch velocity':
                if 'spring extension' and  'spring constant' and 'mass' in knowns:
                    springk,launch_extension,measured_mass = pv.get('spring constant'),pv.get('spring extension'),pv.get('mass')
                    launch_vel(springk,launch_extension,measured_mass)
                    var_value =launch_vel(springk,launch_extension,measured_mass)#entering calculated launch velocity into dictionary
                    projectile_variables[variable] = var_value 
            else:
                    print(message)

            if variable =='maximum height':
                if 'launch velocity' and 'angle of projectile(theta)' in knowns:
                    velocity,angle = pv.get('launch velocity'),pv.get('angle of projectile(theta)')
                    max_height(velocity,angle)
                    var_value =max_height(velocity,angle) #entering calculated maximum height into dictionary
                    projectile_variables[variable] = var_value 
                else:
                    print(message)
          
            if variable =='x velocity':
                if 'launch velocity' and 'angle of projectile(theta)' in knowns:
                   launch_velocity,angle = pv.get('launch velocity'),pv.get('angle of projectile(theta)')
                   horizontal_vel =launch_velocity*math.cos(math.radians(angle))
                   print ('Horizontal component of velocity is',horizontal_vel,'m/s')
                   var_value = horizontal_vel #entering calculated x-velocity into dictionary
                   projectile_variables[variable] = var_value 
                else:
                    print(message)

            if variable =='y velocity':
                if 'launch velocity' and 'angle of projectile(theta)' in knowns:
                    launch_velocity,angle = pv.get('launch velocity'),pv.get('angle of projectile(theta)')
                    vertical_vel =launch_velocity*math.sin(math.radians(angle))
                    print ('Horizontal component of velocity is',vertical_vel,'m/s')
                    var_value = vertical_vel #entering calculated y-velocity into dictionary
                    projectile_variables[variable] = var_value 
                else:
                    print(message)


            if variable =='launch force':
                if 'spring constant' and 'spring extension' in knowns:
                    springk,launch_extension =pv.get('spring constant'),pv.get('spring extension')
                    launch_force(launch_extension,springk)
                    var_value = launch_force(launch_extension,springk)#entering calculated launch force into dictionary
                    projectile_variables[variable] = var_value 
                else:
                    print(message)

            if variable =='weight of mass':
                if 'mass' in knowns:
                    mass =pv.get('mass')
                    weight_of_mass = mass*gravity
                    print('\nweight of mass is',weight_of_mass,'kg\n')
                    var_value = weight_of_mass#entering calculated weight of mass into dictionary
                    projectile_variables[variable] = var_value

                else:
                    if 'spring constant' and 'spring extension' in knowns:
                        print('\nInsufficient variables known for calulating weight of mass\n')
                        print('Devicing new means...\nJust a sec...')
                        time.sleep(5)
                        print('NB: will require spring extension generated at normal rest on inclined plane')

                        rest_extension,springk  = pv.get('spring extension'),pv.get('spring constant')     
                        force(rest_extension, springk)
                        var_value = force(rest_extension,springk)#entering calculated weight of weight of mass into dictionary
                        projectile_variables[variable] = var_value 
                        

            if variable =='max height time':
                if 'launch velocity' and 'angle of projectile(theta)' in knowns:
                    launch_velocity,angle = pv.get('launch velocity'),pv.get('angle of projectile(theta)') 
                    max_height_time(launch_velocity,angle)
                    var_value =max_height_time(launch_velocity,angle)
                    projectile_variables[variable] = var_value

            if variable =='time of flight':
                if 'launch velocity' and 'angle of projectile(theta)' in knowns:
                    launch_velocity,angle = pv.get('launch velocity'),pv.get('angle of projectile(theta)') 
                    time_of_flight(launch_velocity,angle)
                    var_value =time_of_flight(launch_velocity,angle)
                    projectile_variables[variable] = var_value
                  

    
    file =open('projectile_variables.txt','w+')
    header='All values in the data were initialized with 0.\nif the were solved for, their respective results would be floated(with decimal places),\n else they would be without decimals\n\nValues are all in their S.I Units'
    file.write(header)
    
    
    print (header)
    for variable in projectile_variables.keys():
        print('\n')
        print(variable,'=',projectile_variables[variable])
        file.write('\n'+variable +'='+str(projectile_variables[variable])+'\n')

    
    file.write(str(projectile_variables))
    
    
    print('\n\n\n\n')
        
    os.startfile('projectile_variables.txt')
        
                    
    return  projectile_variables




def theta():
    '''This function calculates the value of theta using ariduino and updates the primary dicitonary of variables'''
    angdet = float(input('Input the angle determinant in meters\n:'))
    print('calculating value of projectile angle in degrees...')
    data = serial.Serial(arduino_com_port,9600)
    try:
        data
    except FileNotFoundError(2, 'The system cannot find the file specified.', None, 2):
        print('Check com port, ARDUINO is probably not connected to USB')

    value_list =[]
    valueNum=0
    while valueNum<5:
        value_list.append(data.readline())
        valueNum+=1

    yard = float(value_list[3][1:4])
    print('yard is',yard,'meters\n')
    print('angle determinant is',angdet)
    
    thetaval = math.degrees(math.atan(angdet/yard))
    projectile_variables['angle of projectile(theta)'] =thetaval
    
    print(projectile_variables)
    print('\n value of angle has been added to dictionary')
    
    print('\nangle of projectile is',thetaval,'\n')

    ask =input('calculate other unknown variables, y or n:').upper()
    if ask =='Y':
            print('\n\n\n\n')
            print('Angle of projectile already calculated as known variable, no need to specify'.upper())
            col_proj()
            
    else:
        if ask =='N':
        
            return thetaval


def start():
    '''This runs the whole program'''
    print("This library contains two major functions, COL_PROJ and THETA().\ntheta() calculates the angle of the projectile using the arduino abd col_proj() collects known variables to calculate all specified unknown variables,")
    select =int(input('\nselect 1. for theta() or 2. for col_proj\n:'))
    if select ==1:
        print('\n\n')
        print('running function'.upper())
        theta()
    if select ==2:
        print('\n\n')
        print('running function'.upper())
        col_proj()
    else:
        print('invalid input')
        print('\n\n................. ')
        start()
start()


    

    
        
                     
    
